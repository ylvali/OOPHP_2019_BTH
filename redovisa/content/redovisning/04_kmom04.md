Kmom04 OOPHP
==================================================================
Ett intressant kursmoment där kunskapen om objektorienterad php samt unit tests har fördjupats. Traits och interface har införts i min programmerings teknik och det framkom varför och hur det är mycket användbart. Ett tärningsspel med ”intelligens” dvs att datorspelaren tar beslut beroende på statistisk är skapat. Det hela integrerades i Anax vars kodstruktur har klarnat ytterliggare.

Nytt för detta kmom var användningen av controllers istället för routes. Controllers är en typ av klass som injicieras med $di eller $app, dvs 2 varianter av service containers. För att rätt metoder ska finnas tillgängliga så används ett interface, alltså ett krav på vad som behöver att fungera som klassen implementerar. Genom att ’mounta’ en controller på en path så blir den tillgänglig via ett specifikt sökord, i detta fall  via config->router. Detta instrueras i index.php och sökordet blir tillgängligt för hämtning av app/program via webbläsaren. Det tycks smidigt.
Ett annat plus är att det enkelt går att använda olika vyer på olika metoder inom controllern utan att ändra innehållet. De kan vara stylade på helt olika sätt, men ändå snabbt och smidigt publiceras i ramverket.

Jag har använt controllers tidigare och då definierat det som en styrande punkt i ramverket. Men nu för att skilja det ifrån routes så är det alltså en typ av klass som har uppgiften att styra och sammanställa ramverk och bakomliggande program.

Jag skapade ett nytt DiceGame som implementerar traits och interface (DiceGame2).  Att använda interface som en kravlista för en klass och sedan införa dessa krav med ett trait fungerar mycket bra.  Trait är en sorts klass med metoder som inte kan intiantieras men som kan implementeras och det upprepade gånger. Ett interface kan också implementeras av den egna klassen.  Att använda interface ger en garanti på att rätt funktionalitet finnes och minskar därmed risk för fel.

Viss ”intelligens” implementerades i metoden som bestämmer ifall datorn ska spela vidare eller inte då en runda är vunnen. I DiceGame2 så bestämmer datorn ifall den ska fortsätta spela beroende på om procenten av antal rundor som vunnits är mindre än den probabiliteten för vinst som är. Datorn blir modigare efter ett visst antal rundor och spelar då på högre procent än probabiliteten för vinst.

Vinstprobabiliteten räknas ut utifrån formeln 1 - ((5/6) ^ nr dice).
Den bygger på att det finns 5/6 chans att en tärning inte slår en etta. Probabilitet för independent delar räknas ut genom att multiplicera dem, därmed står (5/6)^antal tärningar för probabiliteten att ingen av tärningarna visar nr 1. Denna probabilitet subtraheras ifrån 1 för att få det motsatta: probabiliteten för att en (eller flera) ettor visas.

Det var intressant att arbeta med probabilitet och låta programmet välja väg beroende på uträkningar och statistik.
Allting testades enligt phpunits enhetstester som har blivit en mer naturlig del av arbetet. Jag använde make test och det gick bra, har bättre koll på make filen nu också.

Jag lyckas få hög kodtäckning och det är tackvare mindre delar i den objektorienterade programmeringen. Både unittest och att göra systemen indelade i mindre delar är delar som jag specifikt lagt vikt vid att jag ska fortsätta med efter detta kmom.
Det har också framgått hur bra det är att ha en automatiserad testing klar då en väljer att bygga vidare på ett system – och då enkelt se att allt fungerar som det ska efter att delar byggs till.

TIL var trait och interface.

Ser fram emot fortsättningen !
/ Ylva
